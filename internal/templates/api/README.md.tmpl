# {{.ProjectName}} API

A production-ready REST API built with Go following clean architecture principles.

## Features

- 🏗️ **Clean Architecture** - Separation of concerns with domain, infrastructure, and API layers
- 🔐 **JWT Authentication** - Secure user authentication and authorization
- 📊 **PostgreSQL Database** - Reliable data persistence with migrations
- 🚀 **Redis Caching** - High-performance caching layer
- 🛡️ **Security Middleware** - CORS, rate limiting, request logging
- 📝 **API Documentation** - OpenAPI/Swagger specification
- 🧪 **Comprehensive Testing** - Unit and integration tests
- 🐳 **Docker Support** - Containerized deployment
- ☸️ **Kubernetes Ready** - Production deployment manifests

## Quick Start

### Prerequisites

- Go 1.21+
- PostgreSQL 13+
- Redis 6+
- Docker (optional)

### Installation

1. Clone the repository:
   ```bash
   git clone <repository-url>
   cd {{.ProjectName}}
   ```

2. Install dependencies:
   ```bash
   go mod tidy
   ```

3. Set up environment variables:
   ```bash
   cp .env.example .env
   # Edit .env with your configuration
   ```

4. Run database migrations:
   ```bash
   ./scripts/migrate.sh up
   ```

5. Start the server:
   ```bash
   go run cmd/api/main.go
   ```

The API will be available at `http://localhost:8080`

## API Endpoints

### Authentication
- `POST /api/v1/auth/register` - Register a new user
- `POST /api/v1/auth/login` - Login user

### Users (Protected)
- `GET /api/v1/users` - Get all users
- `GET /api/v1/users/{id}` - Get user by ID
- `PUT /api/v1/users/{id}` - Update user
- `DELETE /api/v1/users/{id}` - Delete user

### Posts
- `GET /api/v1/posts` - Get all posts (public)
- `GET /api/v1/posts/{id}` - Get post by ID (public)
- `POST /api/v1/posts` - Create post (protected)
- `PUT /api/v1/posts/{id}` - Update post (protected)
- `DELETE /api/v1/posts/{id}` - Delete post (protected)

### Health
- `GET /api/v1/health` - Health check

## Configuration

The application uses YAML configuration files in the `configs/` directory:

- `local.yaml` - Local development
- `staging.yaml` - Staging environment
- `production.yaml` - Production environment

## Database

### Migrations

Run migrations:
```bash
./scripts/migrate.sh up
```

Rollback migrations:
```bash
./scripts/migrate.sh down
```

### Schema

The database includes tables for:
- `users` - User accounts
- `posts` - User posts

## Testing

Run all tests:
```bash
./scripts/test.sh
```

Run specific test suites:
```bash
# Unit tests
go test ./internal/...

# Integration tests
go test ./tests/integration/...
```

## Deployment

### Docker

Build and run with Docker:
```bash
docker-compose up --build
```

### Kubernetes

Deploy to Kubernetes:
```bash
kubectl apply -f deployments/kubernetes/
```

### Manual Deployment

1. Build the binary:
   ```bash
   ./scripts/build.sh
   ```

2. Deploy using your preferred method

## Development

### Project Structure

```
{{.ProjectName}}/
├── cmd/api/                    # Application entry point
├── internal/
│   ├── api/                    # HTTP layer (handlers, middleware, routes)
│   ├── domain/                 # Business logic and entities
│   ├── infrastructure/         # External dependencies (database, auth, etc.)
│   ├── config/                 # Configuration management
│   └── pkg/                    # Shared utilities
├── api/                        # API specifications
├── migrations/                 # Database migrations
├── deployments/                # Deployment configurations
├── scripts/                    # Build and utility scripts
├── tests/                      # Test files
├── configs/                    # Configuration files
└── docs/                       # Documentation
```

### Adding New Features

1. Define domain models in `internal/domain/`
2. Create repository interfaces
3. Implement repository in `internal/infrastructure/database/`
4. Create service layer in domain package
5. Add HTTP handlers in `internal/api/handlers/`
6. Update routes in `internal/api/routes/`
7. Add tests

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests
5. Submit a pull request

## License

This project is licensed under the MIT License - see the LICENSE file for details.
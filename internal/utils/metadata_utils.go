package utils

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"time"
)

// ActivityInfo represents information about a project activity
type ActivityInfo struct {
	Completed bool   `json:"completed"`
	Timestamp string `json:"timestamp,omitempty"`
	CanRepeat bool   `json:"can_repeat"`
}

// ProjectMetadata represents basic project metadata structure
type ProjectMetadata struct {
	Project struct {
		Name        string `json:"name"`
		Type        string `json:"type"`
		LastUpdated string `json:"last_updated"`
	} `json:"project"`
	Database struct {
		MigrationsExecuted bool `json:"migrations_executed"`
		SchemaInitialized  bool `json:"schema_initialized"`
	} `json:"database"`
	Activities map[string]ActivityInfo `json:"activities"`
}

// UpdateActivity updates the status of a specific activity in the project metadata
func UpdateActivity(projectPath, activityName string, completed bool) error {
	metadata, err := LoadMetadata(projectPath)
	if err != nil {
		return fmt.Errorf("failed to load metadata: %w", err)
	}

	if metadata.Activities == nil {
		metadata.Activities = make(map[string]ActivityInfo)
	}

	activity := metadata.Activities[activityName]
	activity.Completed = completed
	if completed {
		activity.Timestamp = time.Now().Format(time.RFC3339)
	}
	metadata.Activities[activityName] = activity
	metadata.Project.LastUpdated = time.Now().Format(time.RFC3339)

	return SaveMetadata(projectPath, metadata)
}

// UpdateDatabaseStatus updates database-related status in the project metadata
func UpdateDatabaseStatus(projectPath string, migrationsExecuted, schemaInitialized bool) error {
	metadata, err := LoadMetadata(projectPath)
	if err != nil {
		return fmt.Errorf("failed to load metadata: %w", err)
	}

	metadata.Database.MigrationsExecuted = migrationsExecuted
	metadata.Database.SchemaInitialized = schemaInitialized
	metadata.Project.LastUpdated = time.Now().Format(time.RFC3339)

	return SaveMetadata(projectPath, metadata)
}

// IsActivityCompleted checks if an activity has been completed
func IsActivityCompleted(projectPath, activityName string) bool {
	metadata, err := LoadMetadata(projectPath)
	if err != nil {
		return false
	}

	if activity, exists := metadata.Activities[activityName]; exists {
		return activity.Completed
	}
	return false
}

// GetActivityPrefix returns "re-" prefix if activity was already completed
func GetActivityPrefix(projectPath, activityName string) string {
	if IsActivityCompleted(projectPath, activityName) {
		return "re-"
	}
	return ""
}

// LoadMetadata loads metadata from gophex.md file
func LoadMetadata(projectPath string) (*ProjectMetadata, error) {
	filePath := filepath.Join(projectPath, "gophex.md")
	content, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read metadata file: %w", err)
	}

	// Extract JSON from markdown
	jsonRegex := regexp.MustCompile(`(?s)` + "```json\n(.*?)\n```")
	matches := jsonRegex.FindSubmatch(content)
	if len(matches) < 2 {
		return nil, fmt.Errorf("no JSON found in metadata file")
	}

	var metadata ProjectMetadata
	err = json.Unmarshal(matches[1], &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal metadata: %w", err)
	}

	return &metadata, nil
}

// SaveMetadata saves metadata to gophex.md file
func SaveMetadata(projectPath string, metadata *ProjectMetadata) error {
	// Convert to JSON with proper formatting
	jsonData, err := json.MarshalIndent(metadata, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal metadata: %w", err)
	}

	// Create the markdown content
	content := fmt.Sprintf(`# Gophex Project Metadata

This file contains project metadata and progress tracking for Gophex-generated projects.
**Do not edit this file manually** - it is automatically maintained by Gophex.

`+"```json\n%s\n```\n", string(jsonData))

	// Write to file
	filePath := filepath.Join(projectPath, "gophex.md")
	err = os.WriteFile(filePath, []byte(content), 0644)
	if err != nil {
		return fmt.Errorf("failed to write metadata file: %w", err)
	}

	return nil
}

// HasGophexMetadata checks if a directory contains a gophex.md file
func HasGophexMetadata(projectPath string) bool {
	filePath := filepath.Join(projectPath, "gophex.md")
	_, err := os.Stat(filePath)
	return err == nil
}

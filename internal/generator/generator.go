package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/buildwithhp/gophex/internal/templates"
	"github.com/buildwithhp/gophex/internal/types"
)

type DatabaseConfig = types.DatabaseConfig
type RedisConfig = types.RedisConfig

type Generator struct{}

func New() *Generator {
	return &Generator{}
}

// generateMetadata creates the gophex.md metadata file
func (g *Generator) generateMetadata(projectType, projectName, projectPath string, dbConfig *DatabaseConfig, redisConfig *RedisConfig) error {
	// Import metadata package here to avoid import cycle
	// We'll use a different approach - create the metadata file directly
	return g.createMetadataFile(projectType, projectName, projectPath, dbConfig, redisConfig)
}

// createMetadataFile creates the metadata file without importing the metadata package
func (g *Generator) createMetadataFile(projectType, projectName, projectPath string, dbConfig *DatabaseConfig, redisConfig *RedisConfig) error {
	// For now, we'll create a simple implementation to avoid import cycles
	// Later we can refactor this to use the metadata package properly

	// Create a basic metadata structure
	now := time.Now().Format(time.RFC3339)

	// Build the JSON content dynamically
	content := fmt.Sprintf(`# Gophex Project Metadata

This file contains project metadata and progress tracking for Gophex-generated projects.
**Do not edit this file manually** - it is automatically maintained by Gophex.

` + "```json\n")

	content += "{\n"
	content += fmt.Sprintf(`  "project": {
    "name": "%s",
    "type": "%s",
    "version": "1.0.0",
    "gophex_version": "1.0.0",
    "generated_at": "%s",
    "last_updated": "%s"
  },`, projectName, projectType, now, now)

	content += "\n  \"hierarchy\": {},\n"

	// Database configuration
	content += "  \"database\": {\n"
	if dbConfig != nil {
		content += "    \"configured\": true,\n"
		content += fmt.Sprintf("    \"type\": \"%s\",\n", dbConfig.Type)
		content += fmt.Sprintf("    \"config_type\": \"%s\",\n", dbConfig.ConfigType)
		content += fmt.Sprintf("    \"is_clustered\": %t,\n", dbConfig.ConfigType == "cluster")
		content += fmt.Sprintf("    \"has_read_write_split\": %t,\n", dbConfig.ConfigType == "read-write")
		content += fmt.Sprintf("    \"ssl_enabled\": %t,\n", dbConfig.SSLMode != "" && dbConfig.SSLMode != "disable")
	} else {
		content += "    \"configured\": false,\n"
		content += "    \"type\": null,\n"
		content += "    \"config_type\": null,\n"
		content += "    \"is_clustered\": false,\n"
		content += "    \"has_read_write_split\": false,\n"
		content += "    \"ssl_enabled\": false,\n"
	}
	content += "    \"migrations_executed\": false,\n"
	content += "    \"schema_initialized\": false\n"
	content += "  },\n"

	// Redis configuration
	content += "  \"redis\": {\n"
	if redisConfig != nil && redisConfig.Enabled {
		content += "    \"configured\": true,\n"
		content += "    \"enabled\": true\n"
	} else {
		content += "    \"configured\": false,\n"
		content += "    \"enabled\": false\n"
	}
	content += "  },\n"

	// Activities
	content += "  \"activities\": {\n"
	content += fmt.Sprintf(`    "project_generated": {
      "completed": true,
      "timestamp": "%s",
      "can_repeat": false
    },
    "dependencies_installed": {
      "completed": false,
      "timestamp": null,
      "can_repeat": true
    },
    "tests_executed": {
      "completed": false,
      "timestamp": null,
      "can_repeat": true
    },
    "project_opened": {
      "completed": false,
      "timestamp": null,
      "can_repeat": true
    },
    "documentation_viewed": {
      "completed": false,
      "timestamp": null,
      "can_repeat": true
    }`, now)

	// Add project-specific activities
	if projectType == "api" {
		content += `,
    "database_migrated": {
      "completed": false,
      "timestamp": null,
      "can_repeat": true
    },
    "application_started": {
      "completed": false,
      "timestamp": null,
      "can_repeat": true
    },
    "change_detection_run": {
      "completed": false,
      "timestamp": null,
      "can_repeat": true
    }`
	} else if projectType == "webapp" || projectType == "microservice" {
		content += `,
    "application_started": {
      "completed": false,
      "timestamp": null,
      "can_repeat": true
    }`
	} else if projectType == "cli" {
		content += `,
    "application_built": {
      "completed": false,
      "timestamp": null,
      "can_repeat": true
    }`
	}

	content += "\n  },\n"

	// Features (basic implementation)
	content += "  \"features\": {\n"
	switch projectType {
	case "api":
		content += `    "authentication": true,
    "user_management": true,
    "post_management": true,
    "health_checks": true,
    "cors_enabled": true,
    "rate_limiting": true,
    "request_logging": true,
    "input_validation": true,
    "structured_logging": true,
    "graceful_shutdown": true,
    "clean_architecture": true`
	case "webapp":
		content += `    "web_server": true,
    "static_files": true,
    "html_templates": true,
    "graceful_shutdown": true`
	case "microservice":
		content += `    "grpc_support": true,
    "health_checks": true,
    "graceful_shutdown": true,
    "lightweight_design": true`
	case "cli":
		content += `    "cobra_framework": true,
    "command_line_interface": true,
    "subcommands": true`
	}
	content += "\n  }\n"

	content += "}\n```\n"

	// Write to file
	filePath := filepath.Join(projectPath, "gophex.md")
	err := os.WriteFile(filePath, []byte(content), 0644)
	if err != nil {
		return fmt.Errorf("failed to write metadata file: %w", err)
	}

	return nil
}

func (g *Generator) Generate(projectType, projectName, projectPath string) error {
	return g.GenerateWithConfig(projectType, projectName, projectPath, nil)
}

func (g *Generator) GenerateWithConfig(projectType, projectName, projectPath string, dbConfig *DatabaseConfig) error {
	return g.GenerateWithFullConfig(projectType, projectName, projectPath, dbConfig, nil)
}

func (g *Generator) GenerateWithFullConfig(projectType, projectName, projectPath string, dbConfig *DatabaseConfig, redisConfig *RedisConfig) error {
	if err := os.MkdirAll(projectPath, 0755); err != nil {
		return fmt.Errorf("failed to create project directory: %w", err)
	}

	var err error
	switch projectType {
	case "api":
		err = g.generateAPI(projectName, projectPath, dbConfig, redisConfig)
	case "webapp":
		err = g.generateWebApp(projectName, projectPath)
	case "microservice":
		err = g.generateMicroservice(projectName, projectPath)
	case "cli":
		err = g.generateCLI(projectName, projectPath)
	default:
		return fmt.Errorf("unsupported project type: %s", projectType)
	}

	if err != nil {
		return err
	}

	// Generate project metadata
	err = g.generateMetadata(projectType, projectName, projectPath, dbConfig, redisConfig)
	if err != nil {
		return fmt.Errorf("failed to generate metadata: %w", err)
	}

	return nil
}

func (g *Generator) generateAPI(projectName, projectPath string, dbConfig *DatabaseConfig, redisConfig *RedisConfig) error {
	return g.createFromTemplate("api", projectName, projectPath, dbConfig, redisConfig)
}

func (g *Generator) generateWebApp(projectName, projectPath string) error {
	return g.createFromTemplate("webapp", projectName, projectPath, nil, nil)
}

func (g *Generator) generateMicroservice(projectName, projectPath string) error {
	return g.createFromTemplate("microservice", projectName, projectPath, nil, nil)
}

func (g *Generator) generateCLI(projectName, projectPath string) error {
	return g.createFromTemplate("cli", projectName, projectPath, nil, nil)
}

func (g *Generator) createFromTemplate(templateType, projectName, projectPath string, dbConfig *DatabaseConfig, redisConfig *RedisConfig) error {
	// Get template files from embedded filesystem
	templateFiles, err := templates.GetTemplateFiles(templateType)
	if err != nil {
		return fmt.Errorf("failed to get template files for %s: %w", templateType, err)
	}

	// Prepare template data
	data := templates.TemplateData{
		ProjectName:   projectName,
		Title:         projectName, // Set Title as alias for ProjectName
		ModuleName:    templates.GenerateModuleName(projectName),
		GeneratedAt:   time.Now().Format(time.RFC3339),
		GophexVersion: "1.0.0", // TODO: Get from version package
		Checksums:     make(map[string]string),
	}

	// Add database configuration if provided
	if dbConfig != nil {
		data.DatabaseConfig = templates.DatabaseConfig{
			Type:         dbConfig.Type,
			ConfigType:   dbConfig.ConfigType,
			Host:         dbConfig.Host,
			Port:         dbConfig.Port,
			Username:     dbConfig.Username,
			Password:     dbConfig.Password,
			DatabaseName: dbConfig.DatabaseName,
			ReadHost:     dbConfig.ReadHost,
			WriteHost:    dbConfig.WriteHost,
			ClusterNodes: dbConfig.ClusterNodes,
			SSLMode:      dbConfig.SSLMode,
			AuthSource:   dbConfig.AuthSource,
			ReplicaSet:   dbConfig.ReplicaSet,
		}
	}

	// Add Redis configuration if provided
	if redisConfig != nil {
		data.RedisConfig = templates.RedisConfig{
			Enabled:  redisConfig.Enabled,
			Host:     redisConfig.Host,
			Port:     redisConfig.Port,
			Password: redisConfig.Password,
			Database: redisConfig.Database,
		}
	}

	for _, file := range templateFiles {
		// Skip Redis-related files if Redis is disabled
		if redisConfig != nil && !redisConfig.Enabled &&
			(strings.Contains(file.Path, "/redis/") || strings.Contains(file.Path, "redis")) {
			continue
		}

		filePath := filepath.Join(projectPath, file.Path)

		if err := os.MkdirAll(filepath.Dir(filePath), 0755); err != nil {
			return fmt.Errorf("failed to create directory for %s: %w", filePath, err)
		}

		// Process template with proper template engine
		content, err := templates.ProcessTemplate(file.Content, data)
		if err != nil {
			return fmt.Errorf("failed to process template for %s: %w", file.Path, err)
		}

		if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
			return fmt.Errorf("failed to write file %s: %w", filePath, err)
		}
	}

	return nil
}
